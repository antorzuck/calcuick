{% extends 'base.html' %}

{% block head %}
<style>
#tsp-canvas {
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    background: #f9fafb;
  max-width: 100%;
    height: auto;
}
.dark #tsp-canvas {
    border-color: #374151;
    background: #1f2937;
}
.city-table {
    width: 100%;
    border-collapse: collapse;
}
.city-table th, .city-table td {
    padding: 0.5rem;
    text-align: left;
    border-bottom: 1px solid #e5e7eb;
}
.dark .city-table th, .dark .city-table td {
    border-color: #374151;
}
.solution-card {
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 0.5rem;
    padding: 1rem;
}
.dark .solution-card {
    background: #1e293b;
    border-color: #334155;
}
</style>
{% endblock %}

{% block body %}
<!-- Main Content -->
<main class="max-w-6xl mx-auto px-4 py-8">
    <!-- Back Button -->
    <div class="mb-6">
        <button onclick="window.history.back()" class="flex items-center space-x-2 text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">
            <i data-lucide="arrow-left" class="w-5 h-5"></i>
            <span>Back to Calculators</span>
        </button>
    </div>

    <!-- Header -->
    <div class="text-center mb-12">
        <div class="w-16 h-16 bg-purple-50 dark:bg-purple-900/30 rounded-xl flex items-center justify-center mx-auto mb-6">
            <i data-lucide="map" class="w-8 h-8 text-purple-600 dark:text-purple-400"></i>
        </div>
        <h1 class="text-3xl md:text-4xl font-bold text-gray-900 dark:text-white mb-4">Traveling Salesman Calculator</h1>
        <p class="text-lg text-gray-600 dark:text-gray-300 max-w-2xl mx-auto">
            Find the shortest possible route that visits each city exactly once and returns to the origin city.
        </p>
    </div>

    <!-- Calculator -->
    <div class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-xl p-8 shadow-lg">
        <!-- Input Section -->
        <div class="mb-8">
            <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">City Configuration</h2>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- Left Column: City Management -->
                <div class="space-y-6">
                    <div>
                        <h3 class="font-medium text-gray-900 dark:text-white mb-3">Add City</h3>
                        <div class="grid grid-cols-3 gap-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">City Name:</label>
                                <input type="text" id="city-name" placeholder="City A" class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">X Coordinate:</label>
                                <input type="number" id="city-x" placeholder="0" class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Y Coordinate:</label>
                                <input type="number" id="city-y" placeholder="0" class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent">
                            </div>
                        </div>
                        <div class="mt-4">
                            <button onclick="addCity()" class="bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded-lg font-medium transition-colors duration-200">
                                Add City
                            </button>
                            <button onclick="addRandomCity()" class="ml-2 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 py-2 px-4 rounded-lg font-medium transition-colors duration-200">
                                Add Random City
                            </button>
                        </div>
                    </div>

                    <div>
                        <h3 class="font-medium text-gray-900 dark:text-white mb-3">City List</h3>
                        <div class="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                            <table class="city-table">
                                <thead class="bg-gray-50 dark:bg-gray-700">
                                    <tr>
                                        <th class="text-sm font-medium text-gray-700 dark:text-gray-300">City</th>
                                        <th class="text-sm font-medium text-gray-700 dark:text-gray-300">X</th>
                                        <th class="text-sm font-medium text-gray-700 dark:text-gray-300">Y</th>
                                        <th class="text-sm font-medium text-gray-700 dark:text-gray-300">Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="city-table-body">
                                    <!-- Cities will be added here -->
                                </tbody>
                            </table>
                        </div>
                        <div class="mt-4">
                            <button onclick="clearCities()" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg font-medium transition-colors duration-200">
                                Clear All Cities
                            </button>
                            <button onclick="loadSampleCities()" class="ml-2 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg font-medium transition-colors duration-200">
                                Load Sample Cities
                            </button>
                        </div>
                    </div>

                    <div>
                        <h3 class="font-medium text-gray-900 dark:text-white mb-3">Algorithm Settings</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                    Algorithm:
                                </label>
                                <select id="algorithm-select" class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent">
                                    <option value="nearest-neighbor">Nearest Neighbor (Fast, Approximate)</option>
                                    <option value="brute-force">Brute Force (Exact, Slow for >10 cities)</option>
                                    <option value="2-opt">2-Opt Improvement (Better Approximation)</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                    Starting City:
                                </label>
                                <select id="start-city" class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent">
                                    <option value="first">First City</option>
                                    <option value="random">Random City</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Visualization -->
                <div class="space-y-6">
                    <h3 class="font-medium text-gray-900 dark:text-white mb-3">Route Visualization</h3>
                    <div class="flex justify-center">
                        <canvas id="tsp-canvas" width="400" height="400"></canvas>
                    </div>
                    <div class="flex justify-center space-x-4">
                        <button onclick="zoomIn()" class="bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 py-2 px-4 rounded-lg font-medium transition-colors duration-200">
                            <i data-lucide="zoom-in" class="w-5 h-5"></i>
                        </button>
                        <button onclick="zoomOut()" class="bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 py-2 px-4 rounded-lg font-medium transition-colors duration-200">
                            <i data-lucide="zoom-out" class="w-5 h-5"></i>
                        </button>
                        <button onclick="resetZoom()" class="bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 py-2 px-4 rounded-lg font-medium transition-colors duration-200">
                            Reset View
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Buttons -->
        <div class="flex flex-col sm:flex-row gap-4 mb-8">
            <button onclick="solveTSP()" class="flex-1 bg-purple-600 hover:bg-purple-700 text-white py-3 px-6 rounded-lg font-medium transition-colors duration-200">
                Solve Traveling Salesman Problem
            </button>
            <button onclick="exportSolution()" class="flex-1 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 py-3 px-6 rounded-lg font-medium transition-colors duration-200">
                Export Solution
            </button>
        </div>

        <!-- Results -->
        <div id="result-container" class="hidden">
            <div class="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold text-green-800 dark:text-green-300 mb-4">Solution Found</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="solution-card">
                        <h4 class="font-medium text-gray-900 dark:text-white mb-2">Total Distance:</h4>
                        <div id="total-distance" class="text-2xl font-bold text-purple-600 dark:text-purple-400"></div>
                    </div>
                    
                    <div class="solution-card">
                        <h4 class="font-medium text-gray-900 dark:text-white mb-2">Number of Cities:</h4>
                        <div id="city-count" class="text-2xl font-bold text-purple-600 dark:text-purple-400"></div>
                    </div>
                    
                    <div class="solution-card">
                        <h4 class="font-medium text-gray-900 dark:text-white mb-2">Algorithm Used:</h4>
                        <div id="algorithm-used" class="text-2xl font-bold text-purple-600 dark:text-purple-400"></div>
                    </div>
                </div>
            </div>
            
            <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold text-blue-800 dark:text-blue-300 mb-4">Optimal Route</h3>
                
                <div class="space-y-4">
                    <div>
                        <h4 class="font-medium text-blue-700 dark:text-blue-400 mb-2">Route Order:</h4>
                        <div id="route-order" class="text-gray-800 dark:text-gray-200"></div>
                    </div>
                    
                    <div>
                        <h4 class="font-medium text-blue-700 dark:text-blue-400 mb-2">Route Details:</h4>
                        <div class="overflow-x-auto">
                            <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                                <thead class="bg-gray-50 dark:bg-gray-800">
                                    <tr>
                                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Step</th>
                                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">From</th>
                                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">To</th>
                                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Distance</th>
                                    </tr>
                                </thead>
                                <tbody id="route-table-body" class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                                    <!-- Route steps will be inserted here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-800 rounded-lg p-6">
                <h3 class="text-xl font-semibold text-purple-800 dark:text-purple-300 mb-4">Performance Analysis</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h4 class="font-medium text-purple-700 dark:text-purple-400 mb-2">Computation Time:</h4>
                        <div id="computation-time" class="text-gray-800 dark:text-gray-200"></div>
                    </div>
                    
                    <div>
                        <h4 class="font-medium text-purple-700 dark:text-purple-400 mb-2">Solution Quality:</h4>
                        <div id="solution-quality" class="text-gray-800 dark:text-gray-200"></div>
                    </div>
                </div>
                
                <div class="mt-4">
                    <h4 class="font-medium text-purple-700 dark:text-purple-400 mb-2">Algorithm Insights:</h4>
                    <div id="algorithm-insights" class="text-gray-800 dark:text-gray-200"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- How to Use -->
    <div class="mt-12 bg-gray-50 dark:bg-gray-800/50 rounded-xl p-8">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-6">About the Traveling Salesman Problem</h2>
        
        <div class="space-y-6">
            <div>
                <h3 class="font-semibold text-gray-900 dark:text-white mb-2">What is the Traveling Salesman Problem?</h3>
                <p class="text-gray-600 dark:text-gray-300">
                    The Traveling Salesman Problem (TSP) is a classic optimization problem: given a list of cities and the distances between them, 
                    what is the shortest possible route that visits each city exactly once and returns to the origin city? Despite its simple 
                    description, the TSP is notoriously difficult to solve optimally for large numbers of cities.
                </p>
            </div>
            
            <div>
                <h3 class="font-semibold text-gray-900 dark:text-white mb-2">Algorithms Used</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
                        <h4 class="font-medium text-gray-900 dark:text-white mb-2">Nearest Neighbor</h4>
                        <p class="text-gray-600 dark:text-gray-300 text-sm">
                            A greedy algorithm that always visits the nearest unvisited city next. Fast but may not find the optimal solution.
                        </p>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
                        <h4 class="font-medium text-gray-900 dark:text-white mb-2">Brute Force</h4>
                        <p class="text-gray-600 dark:text-gray-300 text-sm">
                            Checks all possible routes to find the optimal solution. Guaranteed to be optimal but extremely slow for more than 10 cities.
                        </p>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
                        <h4 class="font-medium text-gray-900 dark:text-white mb-2">2-Opt Improvement</h4>
                        <p class="text-gray-600 dark:text-gray-300 text-sm">
                            Improves an existing route by swapping pairs of edges to reduce the total distance. Good balance of speed and quality.
                        </p>
                    </div>
                </div>
            </div>
            
            <div>
                <h3 class="font-semibold text-gray-900 dark:text-white mb-2">Real-World Applications</h3>
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
                    <ul class="list-disc list-inside space-y-2 text-gray-600 dark:text-gray-300">
                        <li><strong>Logistics and Delivery:</strong> Optimizing delivery routes for packages or services</li>
                        <li><strong>Circuit Board Manufacturing:</strong> Minimizing the movement of drilling equipment</li>
                        <li><strong>DNA Sequencing:</strong> Ordering DNA fragments efficiently</li>
                        <li><strong>Network Design:</strong> Optimizing the layout of telecommunications networks</li>
                        <li><strong>Vehicle Routing:</strong> Planning routes for multiple vehicles with various constraints</li>
                    </ul>
                </div>
            </div>
            
            <div>
                <h3 class="font-semibold text-gray-900 dark:text-white mb-2">How to Use This Calculator</h3>
                <ol class="list-decimal list-inside space-y-2 text-gray-600 dark:text-gray-300">
                    <li>Add cities by entering their names and coordinates, or use the "Add Random City" button</li>
                    <li>Select an algorithm based on your problem size and accuracy needs</li>
                    <li>Choose a starting city option</li>
                    <li>Click "Solve Traveling Salesman Problem" to find the optimal route</li>
                    <li>View the solution details and route visualization</li>
                    <li>Export the solution for your records or further analysis</li>
                </ol>
            </div>
            
            <div>
                <h3 class="font-semibold text-gray-900 dark:text-white mb-2">Computational Complexity</h3>
                <p class="text-gray-600 dark:text-gray-300 mb-4">
                    The TSP is an NP-hard problem, meaning that as the number of cities increases, the time required to solve it optimally 
                    grows exponentially. For n cities, there are (n-1)!/2 possible routes to check in the worst case:
                </p>
                <div class="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
                    <table class="min-w-full">
                        <thead>
                            <tr>
                                <th class="text-left text-sm font-medium text-gray-700 dark:text-gray-300">Cities</th>
                                <th class="text-left text-sm font-medium text-gray-700 dark:text-gray-300">Possible Routes</th>
                                <th class="text-left text-sm font-medium text-gray-700 dark:text-gray-300">Brute Force Time</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="text-gray-600 dark:text-gray-300">5</td>
                                <td class="text-gray-600 dark:text-gray-300">12</td>
                                <td class="text-gray-600 dark:text-gray-300">< 1 second</td>
                            </tr>
                            <tr>
                                <td class="text-gray-600 dark:text-gray-300">10</td>
                                <td class="text-gray-600 dark:text-gray-300">181,440</td>
                                <td class="text-gray-600 dark:text-gray-300">~ seconds</td>
                            </tr>
                            <tr>
                                <td class="text-gray-600 dark:text-gray-300">15</td>
                                <td class="text-gray-600 dark:text-gray-300">43 billion</td>
                                <td class="text-gray-600 dark:text-gray-300">~ years</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</main>

<!-- JavaScript -->
<script>
// Global variables
let cities = [];
let solution = null;
let canvas, ctx;
let scale = 1;
let offsetX = 0, offsetY = 0;

// Initialize canvas
function initCanvas() {
    canvas = document.getElementById('tsp-canvas');
    ctx = canvas.getContext('2d');
    resetZoom();
    drawCities();
}

// Clear canvas
function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set background
    const isDark = document.documentElement.classList.contains('dark');
    ctx.fillStyle = isDark ? '#1f2937' : '#f9fafb';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    ctx.strokeStyle = isDark ? '#374151' : '#e5e7eb';
    ctx.lineWidth = 0.5;
    
    const gridSize = 20;
    for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    
    for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

// Draw cities on canvas
function drawCities() {
    clearCanvas();
    
    if (cities.length === 0) return;
    
    const isDark = document.documentElement.classList.contains('dark');
    
    // Draw cities
    cities.forEach((city, index) => {
        const x = transformX(city.x);
        const y = transformY(city.y);
        
        // Draw city point
        ctx.fillStyle = isDark ? '#a78bfa' : '#8b5cf6';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw city name
        ctx.fillStyle = isDark ? '#e5e7eb' : '#374151';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(city.name, x, y - 8);
        
        // Draw city index
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(index + 1, x, y);
    });
    
    // Draw solution path if available
    if (solution && solution.path) {
        ctx.strokeStyle = isDark ? '#22c55e' : '#16a34a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const firstCity = cities[solution.path[0]];
        ctx.moveTo(transformX(firstCity.x), transformY(firstCity.y));
        
        for (let i = 1; i < solution.path.length; i++) {
            const city = cities[solution.path[i]];
            ctx.lineTo(transformX(city.x), transformY(city.y));
        }
        
        // Close the loop
        ctx.lineTo(transformX(firstCity.x), transformY(firstCity.y));
        ctx.stroke();
    }
}

// Transform coordinates based on zoom and offset
function transformX(x) {
    return (x * scale) + offsetX + (canvas.width / 2);
}

function transformY(y) {
    return (y * scale) + offsetY + (canvas.height / 2);
}

// Zoom functions
function zoomIn() {
    scale *= 1.2;
    drawCities();
}

function zoomOut() {
    scale /= 1.2;
    drawCities();
}

function resetZoom() {
    scale = 1;
    offsetX = 0;
    offsetY = 0;
    drawCities();
}

// Add a city
function addCity() {
    const name = document.getElementById('city-name').value || `City ${cities.length + 1}`;
    const x = parseFloat(document.getElementById('city-x').value) || 0;
    const y = parseFloat(document.getElementById('city-y').value) || 0;
    
    cities.push({ name, x, y });
    updateCityTable();
    drawCities();
    
    // Clear inputs
    document.getElementById('city-name').value = '';
    document.getElementById('city-x').value = '';
    document.getElementById('city-y').value = '';
}

// Add a random city
function addRandomCity() {
    const name = `City ${cities.length + 1}`;
    const x = Math.floor(Math.random() * 200) - 100;
    const y = Math.floor(Math.random() * 200) - 100;
    
    cities.push({ name, x, y });
    updateCityTable();
    drawCities();
}

// Update city table
function updateCityTable() {
    const tableBody = document.getElementById('city-table-body');
    tableBody.innerHTML = '';
    
    cities.forEach((city, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td class="text-sm text-gray-900 dark:text-gray-100">${city.name}</td>
            <td class="text-sm text-gray-900 dark:text-gray-100">${city.x}</td>
            <td class="text-sm text-gray-900 dark:text-gray-100">${city.y}</td>
            <td class="text-sm text-gray-900 dark:text-gray-100">
                <button onclick="removeCity(${index})" class="text-red-500 hover:text-red-700">
                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                </button>
            </td>
        `;
        tableBody.appendChild(row);
    });
    
    // Update the lucide icons
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
    
    // Update start city dropdown
    updateStartCityDropdown();
}

// Update start city dropdown
function updateStartCityDropdown() {
    const startCitySelect = document.getElementById('start-city');
    startCitySelect.innerHTML = '<option value="first">First City</option><option value="random">Random City</option>';
    
    cities.forEach((city, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = city.name;
        startCitySelect.appendChild(option);
    });
}

// Remove a city
function removeCity(index) {
    cities.splice(index, 1);
    updateCityTable();
    drawCities();
}

// Clear all cities
function clearCities() {
    cities = [];
    updateCityTable();
    drawCities();
    hideResults();
}

// Load sample cities
function loadSampleCities() {
    cities = [
        { name: "City A", x: 0, y: 0 },
        { name: "City B", x: 50, y: 30 },
        { name: "City C", x: 30, y: 70 },
        { name: "City D", x: -20, y: 40 },
        { name: "City E", x: -40, y: -10 },
        { name: "City F", x: 10, y: -30 }
    ];
    updateCityTable();
    drawCities();
}

// Calculate distance between two cities
function calculateDistance(city1, city2) {
    const dx = city1.x - city2.x;
    const dy = city1.y - city2.y;
    return Math.sqrt(dx * dx + dy * dy);
}

// Nearest neighbor algorithm
function nearestNeighborAlgorithm(startIndex = 0) {
    if (cities.length < 2) return { path: [0], distance: 0 };
    
    const visited = new Array(cities.length).fill(false);
    const path = [startIndex];
    let totalDistance = 0;
    
    visited[startIndex] = true;
    
    while (path.length < cities.length) {
        let currentCity = cities[path[path.length - 1]];
        let nearestCityIndex = -1;
        let minDistance = Infinity;
        
        for (let i = 0; i < cities.length; i++) {
            if (!visited[i]) {
                const distance = calculateDistance(currentCity, cities[i]);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestCityIndex = i;
                }
            }
        }
        
        path.push(nearestCityIndex);
        visited[nearestCityIndex] = true;
        totalDistance += minDistance;
    }
    
    // Add distance back to start
    totalDistance += calculateDistance(cities[path[path.length - 1]], cities[path[0]]);
    
    return { path, distance: totalDistance };
}

// Brute force algorithm (permutation)
function bruteForceAlgorithm(startIndex = 0) {
    if (cities.length < 2) return { path: [0], distance: 0 };
    if (cities.length > 10) {
        alert("Brute force algorithm is too slow for more than 10 cities. Using nearest neighbor instead.");
        return nearestNeighborAlgorithm(startIndex);
    }
    
    // Create array of city indices excluding start
    const indices = [];
    for (let i = 0; i < cities.length; i++) {
        if (i !== startIndex) indices.push(i);
    }
    
    // Generate all permutations
    const permutations = getPermutations(indices);
    
    let bestPath = null;
    let minDistance = Infinity;
    
    for (const perm of permutations) {
        // Add start index to beginning
        const path = [startIndex, ...perm];
        
        // Calculate total distance
        let totalDistance = 0;
        for (let i = 0; i < path.length - 1; i++) {
            totalDistance += calculateDistance(cities[path[i]], cities[path[i + 1]]);
        }
        
        // Add distance back to start
        totalDistance += calculateDistance(cities[path[path.length - 1]], cities[path[0]]);
        
        if (totalDistance < minDistance) {
            minDistance = totalDistance;
            bestPath = path;
        }
    }
    
    return { path: bestPath, distance: minDistance };
}

// Generate all permutations of an array
function getPermutations(arr) {
    if (arr.length <= 1) return [arr];
    
    const result = [];
    
    for (let i = 0; i < arr.length; i++) {
        const current = arr[i];
        const remaining = [...arr.slice(0, i), ...arr.slice(i + 1)];
        const permutations = getPermutations(remaining);
        
        for (const perm of permutations) {
            result.push([current, ...perm]);
        }
    }
    
    return result;
}

// 2-opt improvement algorithm
function twoOptAlgorithm(startIndex = 0) {
    // Start with nearest neighbor solution
    let solution = nearestNeighborAlgorithm(startIndex);
    let improved = true;
    
    while (improved) {
        improved = false;
        
        for (let i = 0; i < solution.path.length - 2; i++) {
            for (let j = i + 2; j < solution.path.length; j++) {
                // Skip if j is the last element and i is 0 (would create a disconnected path)
                if (j === solution.path.length - 1 && i === 0) continue;
                
                // Calculate current distance
                const a = solution.path[i];
                const b = solution.path[i + 1];
                const c = solution.path[j];
                const d = solution.path[(j + 1) % solution.path.length];
                
                const currentDistance = calculateDistance(cities[a], cities[b]) + calculateDistance(cities[c], cities[d]);
                const newDistance = calculateDistance(cities[a], cities[c]) + calculateDistance(cities[b], cities[d]);
                
                if (newDistance < currentDistance) {
                    // Reverse the path between i+1 and j
                    solution.path = [
                        ...solution.path.slice(0, i + 1),
                        ...solution.path.slice(i + 1, j + 1).reverse(),
                        ...solution.path.slice(j + 1)
                    ];
                    
                    // Recalculate total distance
                    let totalDistance = 0;
                    for (let k = 0; k < solution.path.length - 1; k++) {
                        totalDistance += calculateDistance(cities[solution.path[k]], cities[solution.path[k + 1]]);
                    }
                    totalDistance += calculateDistance(cities[solution.path[solution.path.length - 1]], cities[solution.path[0]]);
                    solution.distance = totalDistance;
                    
                    improved = true;
                    break;
                }
            }
            if (improved) break;
        }
    }
    
    return solution;
}

// Solve TSP
function solveTSP() {
    if (cities.length < 3) {
        alert("Please add at least 3 cities to solve the TSP.");
        return;
    }
    
    const algorithm = document.getElementById('algorithm-select').value;
    const startCityOption = document.getElementById('start-city').value;
    
    let startIndex = 0;
    if (startCityOption === 'random') {
        startIndex = Math.floor(Math.random() * cities.length);
    } else if (startCityOption !== 'first') {
        startIndex = parseInt(startCityOption);
    }
    
    const startTime = performance.now();
    
    switch (algorithm) {
        case 'nearest-neighbor':
            solution = nearestNeighborAlgorithm(startIndex);
            break;
        case 'brute-force':
            solution = bruteForceAlgorithm(startIndex);
            break;
        case '2-opt':
            solution = twoOptAlgorithm(startIndex);
            break;
        default:
            solution = nearestNeighborAlgorithm(startIndex);
    }
    
    const endTime = performance.now();
    const computationTime = endTime - startTime;
    
    // Display results
    displayResults(solution, algorithm, computationTime);
    
    // Draw solution
    drawCities();
}

// Display results
function displayResults(solution, algorithm, computationTime) {
    document.getElementById('result-container').classList.remove('hidden');
    
    // Basic metrics
    document.getElementById('total-distance').textContent = solution.distance.toFixed(2) + " units";
    document.getElementById('city-count').textContent = cities.length;
    
    let algorithmName;
    switch (algorithm) {
        case 'nearest-neighbor':
            algorithmName = "Nearest Neighbor";
            break;
        case 'brute-force':
            algorithmName = "Brute Force";
            break;
        case '2-opt':
            algorithmName = "2-Opt Improvement";
            break;
        default:
            algorithmName = algorithm;
    }
    document.getElementById('algorithm-used').textContent = algorithmName;
    
    // Route order
    const routeNames = solution.path.map(index => cities[index].name);
    routeNames.push(cities[solution.path[0]].name); // Add first city again to complete the loop
    document.getElementById('route-order').textContent = routeNames.join(" → ");
    
    // Route details table
    const routeTableBody = document.getElementById('route-table-body');
    routeTableBody.innerHTML = '';
    
    for (let i = 0; i < solution.path.length; i++) {
        const fromIndex = solution.path[i];
        const toIndex = solution.path[(i + 1) % solution.path.length];
        
        const fromCity = cities[fromIndex];
        const toCity = cities[toIndex];
        const distance = calculateDistance(fromCity, toCity);
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-gray-100">${i + 1}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-gray-100">${fromCity.name}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-gray-100">${toCity.name}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-gray-100">${distance.toFixed(2)}</td>
        `;
        routeTableBody.appendChild(row);
    }
    
    // Performance analysis
    document.getElementById('computation-time').textContent = `${computationTime.toFixed(2)} ms`;
    
    let solutionQuality;
    switch (algorithm) {
        case 'brute-force':
            solutionQuality = "Optimal (guaranteed)";
            break;
        case '2-opt':
            solutionQuality = "Near-optimal (local optimum)";
            break;
        case 'nearest-neighbor':
            solutionQuality = "Approximate (greedy heuristic)";
            break;
        default:
            solutionQuality = "Unknown";
    }
    document.getElementById('solution-quality').textContent = solutionQuality;
    
    let insights;
    if (cities.length <= 5) {
        insights = "For small problems like this, all algorithms can find good solutions quickly.";
    } else if (cities.length <= 10) {
        insights = "For medium-sized problems, brute force is still feasible but can be slow. 2-Opt often finds optimal or near-optimal solutions.";
    } else {
        insights = "For large problems, brute force becomes impractical. Heuristic methods like Nearest Neighbor and 2-Opt provide good approximations.";
    }
    document.getElementById('algorithm-insights').textContent = insights;
    
    // Scroll to results
    setTimeout(() => {
        document.getElementById('result-container').scrollIntoView({ 
            behavior: 'smooth',
            block: 'start'
        });
    }, 100);
}

// Hide results
function hideResults() {
    document.getElementById('result-container').classList.add('hidden');
    solution = null;
}

// Export solution
function exportSolution() {
    if (!solution) {
        alert("Please solve the TSP first.");
        return;
    }
    
    let output = "Traveling Salesman Problem Solution\n";
    output += "===================================\n\n";
    
    output += `Number of Cities: ${cities.length}\n`;
    output += `Total Distance: ${solution.distance.toFixed(2)} units\n\n`;
    
    output += "Cities:\n";
    cities.forEach((city, index) => {
        output += `${index + 1}. ${city.name} (${city.x}, ${city.y})\n`;
    });
    
    output += "\nOptimal Route:\n";
    for (let i = 0; i < solution.path.length; i++) {
        const fromIndex = solution.path[i];
        const toIndex = solution.path[(i + 1) % solution.path.length];
        
        const fromCity = cities[fromIndex];
        const toCity = cities[toIndex];
        const distance = calculateDistance(fromCity, toCity);
        
        output += `${i + 1}. ${fromCity.name} → ${toCity.name}: ${distance.toFixed(2)} units\n`;
    }
    
    // Create and download file
    const blob = new Blob([output], { type: 'text/plain' });
    const link = document.createElement('a');
    link.download = 'tsp-solution.txt';
    link.href = window.URL.createObjectURL(blob);
    link.click();
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    initCanvas();
    
    // Add canvas drag functionality
    let isDragging = false;
    let lastX, lastY;
    
    canvas.addEventListener('mousedown', function(e) {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    
    canvas.addEventListener('mousemove', function(e) {
        if (isDragging) {
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            
            offsetX += dx;
            offsetY += dy;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            drawCities();
        }
    });
    
    canvas.addEventListener('mouseup', function() {
        isDragging = false;
    });
    
    canvas.addEventListener('mouseleave', function() {
        isDragging = false;
    });
    
    // Initialize lucide icons
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
});
</script>
{% endblock %}
